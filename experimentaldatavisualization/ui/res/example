好的，为了实现路径遍历中的模糊查询功能，我们需要对原有的代码进行一定的改动。

首先，我们可以添加一个参数`pattern`来指定模糊查询的匹配模式。在此处，我们可以使用Python自带的`fnmatch`模块来实现对文件夹名的模糊匹配操作。具体地，在每次遍历子目录时，我们将当前子目录名与指定的模糊匹配模式进行匹配。如果匹配成功，则将该子节点作为字典的键，并继续递归调用自身；否则跳过该子节点。同时，在根目录下匹配不到的子目录会直接被忽略，因为它们不符合模糊匹配的条件。

```python
import fnmatch

def walk_tree(directory, max_depth, pattern=None, current_depth=0):
    if current_depth == max_depth:
        return None
    result = {}
    for name in os.listdir(directory):
        path = os.path.join(directory, name)
        if os.path.isdir(path):
            if not pattern or fnmatch.fnmatch(name, pattern):
                result[name] = walk_tree(path, max_depth, pattern, current_depth + 1) or {}
    return result or None
```

然后，为了实现“不能影响最上层的文件夹显示”的功能，我们需要在递归结束后，对返回结果进行检查和处理。具体地，在递归深度为1时，我们不对结果进行任何处理，直接返回；在递归深度大于1时，我们将该节点作为字典的键，并创建一个字典来存储其子节点。

```python
def walk_tree(directory, max_depth, pattern=None, current_depth=0):
    if current_depth == max_depth:
        return None
    result = {}
    for name in os.listdir(directory):
        path = os.path.join(directory, name)
        if os.path.isdir(path):
            if not pattern or fnmatch.fnmatch(name, pattern):
                sub_dirs = walk_tree(path, max_depth, pattern, current_depth + 1) or {}
                if current_depth == 0 or len(sub_dirs) > 0:
                    result[name] = sub_dirs
    return result or None
```

最后，在API中我们需要做一些修改，在请求数据中添加参数`pattern`和`top_level`。其中，参数`pattern`用于指定匹配模式，参数`top_level`表示是否对最上层的文件夹进行模糊查询。代码如下所示：

```python
@app.route('/list_dirs', methods=['POST'])
def list_dirs():
    data = request.json
    directory = data['directory']
    max_depth = data['max_depth']
    pattern = data.get('pattern')
    top_level = data.get('top_level', False)
    if not top_level:
        result = {os.path.basename(directory): walk_tree(directory, max_depth, pattern)}
    else:
        result = walk_tree(directory, max_depth, pattern)
    return jsonify(result)
```

如果参数`top_level`为True，则返回根目录下所有符合条件的子目录（包括更深层次的子目录），否则返回以根目录名称为键的字典，该字典中只包含符合条件的子节点。

希望这个修改能够满足客户的需求。




好的，以下是对函数的进一步优化，它可以根据客户输入的关键词对目录表目录下的子目录进行模糊匹配查询：

import os
import json


def traverse_dirs(root_dir, key_word=''):
    """
    遍历指定路径下的所有目录，并将结果构建成Json数据返回
    :param root_dir: 待遍历的根目录
    :param key_word: 关键词，用于模糊匹配目录名称，如果为空则不进行匹配，可选参数。
    :return: 以Json格式返回遍历结果
    """
    result = {}

    def traverse(path, depth=1):
        if depth > 2:
            return
        items = []
        for file_name in os.listdir(path):
            file_path = os.path.join(path, file_name)
            if os.path.isdir(file_path):
                if key_word and key_word not in file_name:
                    continue
                item = {
                    'name': file_name,
                    'path': file_path,
                    'children': []
                }
                item['children'] = traverse(file_path, depth + 1)
                if item['children'] or key_word in item['name']:
                    items.append(item)
        return items

    result['name'] = os.path.basename(root_dir)
    result['path'] = root_dir
    result['children'] = traverse(root_dir)
    return json.dumps(result)
函数说明：

root_dir: 待遍历的根目录，必需参数。
key_word: 关键词，用于模糊匹配目录名称，如果为空则不进行匹配，可选参数。
函数返回值为Json格式的字符串，其中每个目录都包含了以下信息：

name: 目录名称。
path: 目录所在路径。
children: 子目录列表，每个子目录也包含了以上三个信息，如果子目录下还有子目录，则继续嵌套。如果子目录名称包含了关键词或者其子目录下有符合条件的子目录，则将该目录包含在结果中。